\documentclass[a4paper]{article}
\usepackage[top=1in,bottom=1in,left=1in,right=1in]{geometry}
\usepackage{times}
\usepackage{amssymb}
\usepackage{mathtools}	% pulls in amsmath
	\mathtoolsset{centercolon}
\usepackage{tikz}
	\usetikzlibrary{automata}
	\usepackage{tikz-qtree}
\usepackage{mathpartir}
\usepackage{amsthm}
\usepackage{amsxtra}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{semantic}
	\reservestyle{\declarevars}{\texttt}
	\reservestyle{\declareops}{\texttt}
	\reservestyle{\declarestates}{\text}
\usepackage{color}
\usepackage{listings}
\usepackage{mathtools}
\usepackage[shortlabels]{enumitem}
\usepackage{graphicx}	% for pdf image

\newtheorem{theorem}{Theorem}

\newtheorem{myexample}{\textbf{Example}}
\newtheorem{mylemma}{\textbf{Lemma}}
\newtheorem{myproof}{\textbf{Proof}}
\newtheorem{myinvariant}{\textbf{Invariant}}
\newtheorem{mytheorem}{\textbf{Theorem}}
\newtheorem{mycorollary}{\textbf{Corollary}}
\newtheorem{myapproach}{Approach}
\newtheorem{myproperty}{Property}
\newtheorem{mydefinition}{Definition}

\newtheorem{mycase}{Case}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\small,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=,    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
 % frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  columns=fullflexible,	% not monospace
  keywordstyle=,       % keyword style
  language=Octave,                 % the language of the code
  morekeywords={then, end, and, or, assign, increment, decrement, jump, jump_if, store, *, +},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=,     % string literal style
  tabsize=4,                       % sets default tabsize to 2 spaces
  title=\lstname,                  % show the filename of files included with \lstinputlisting; also try caption instead of title
  mathescape,
  belowskip=-\baselineskip,
}

\DeclareMathOperator{\prob}{prob}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\key}{key}
\newcommand*{\floor}[1]{\left\lfloor{#1}\right\rfloor}
\newcommand*{\ceil}[1]{\left\lceil{#1}\right\rceil}
\newcommand{\any}{{\rule[-.2ex]{1ex}{.4pt}}}	% Less hideous than \_.
\newcommand{\RR}{\mathbb{R}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\RP}{\RR_{\ge 0}}
\newcommand*{\dave}[1]{{\color{red}\textbf{PDS: #1}}}
\newcommand{\ie}{\emph{i.e.,} }
\newcommand{\eg}{\emph{e.g.,} }
\usepackage{hyperref}
\newcommand*{\Sref}[1]{\hyperref[#1]{\S\ref*{#1}}}
\newcommand*{\figref}[1]{\hyperref[#1]{Figure~\ref*{#1}}}
\newcommand{\edge}{\longrightarrow}
\newcommand{\redge}{\longleftarrow}

\title{Exercise Sheet 6---Algorithms and Data Structures}
\author{Felipe Cerqueira \\ 2547787 \and David Swasey \\ 2542105}

\begin{document}

\maketitle

Tutorial time: Monday 14:00

\section*{Exercise 1 (15 pts)}

Let $G$ be a directed graph, where each edge is colored either red or blue.
Let $u$ and $v$ be two vertices of $G$.
\begin{enumerate}[a)]
	\item Design an efficient algorithm to decide whether there exists a directed path from $u$ to $v$ that contains at least twice as many red edges as blue edges.
	
	\item Design an efficient algorithm for finding a path from $u$ to $v$ that contains as few red edges as possible.
	
	\item Design an efficient algorithm for finding a path from $u$ to $v$ that contains exactly two red edges, if such a path exists, or otherwise reports failure.
\end{enumerate}

\paragraph{Answer for (1a).}
Here and in~(1c), we represent sets of vertices $S \subseteq V$ using bit vectors or by reserving bits in each vertex.
This makes initialization ($S \gets \emptyset$) linear, update ($S \gets S \cup \{ x \}$) constant, and intersection ($S \cap S'$) linear.
We omit the details.

We identify two subproblems.
\begin{itemize}
	\item If, along a path $p$ from $u$ to $v$, we touch a cycle $C$ that contains one more red edge than blue edges, then we win.
	We can use $p$, running round $C$ up to $2|p|$ times to achieve our goal.

	\item Assuming we have dealt with such cycles, we can perform a DFS or BFS, keeping track of how many red and blue edges we've passed and noticing if we reach $v$ with enough red edges.
\end{itemize}
We punt on the first subproblem.
For the second, we use a variant on DFS:
\begin{lstlisting}[numbers=none,xleftmargin=1cm]
search$(s)$: $M \gets \emptyset$; dfs$(u, 0, 0)$; output NO
check$(x, r, b)$: if $x = v \land r \ge 2b$ then output YES and halt
dfs$(x, r, b)$:
	check$(x, r, b)$
	$M \gets M \cup \{ x \}$
	for $y \in \text{Adj}[x]$
		if $y \not\in M \land (x,y)\text{ red}$ then dfs$(y, r+1, b)$
		else if $y \not\in M \land (x,y)\text{ blue}$ then dfs$(y, r, b+1)$
		else if $y \in M \land (x,y)\text{ red}$ then check$(y,r+1,b)$\end{lstlisting}
The set $M$ marks visited vertices.
Reaching $(x, r, b)$ means we've found a path from $u$ to vertex $x$ containing $r$ red and $b$ blue edges.
Notice that we check (but, of course, do not recurse into) \emph{red} back and cross edges.

\paragraph{Answer for (1b).}
We use Dijkstra's algorithm to solve this in $O(E + V \log V)$ time.
	Define $c(e) := 1$ if $e$ red; $0$ otherwise.
	Run Dijkstra's algorithm with source $u$.
	Return the shortest path to $v$, if any.

\paragraph{Answer for (1c).}
Assume a function search$(G, x)$ that runs in time $O(V+E)$ and returns the set of vertices reachable from $x$ by paths containing exactly one red edge.
Given such a function, we proceed as follows.
\begin{itemize}
	\item
	$O(V+E)$: $S_1 \gets \text{search}(G, u)$

	\item
	$O(V+E)$: $S_2 \gets \text{search}(G^\text{op}, v)$, where $G^\text{op}$ has edges reversed

	\item
	$O(V):$ Output YES if $S_1 \cap S_2 \not= \emptyset$; otherwise NO.
\end{itemize}
The search function is implicitly parameterized by a graph $G=(V,E)$.
It's a simple variant on DFS and uses an additional set $M$ of marked nodes:
\begin{lstlisting}[numbers=none,xleftmargin=1cm]
search$(s)$:
	$S \gets \emptyset$; $M \gets \emptyset$
	dfs$(s, 0)$
	return $S$
save$(x, b)$: if $b=1$ then $S \gets S \cup \{ x \}$
dfs$(x, b)$:
	save$(x, b)$
	$M \gets M \cup \{ x \}$
	for $y \in \text{Adj}[x]$
		if $b=1 \land (x,y)$ red
			continue
		$b' \gets$ if $(x,y)$ red then $1$ else $0$
		if $y \in M$ then save$(y, b')$ else dfs$(y, b')$\end{lstlisting}
The search proceeds in two stages.
When $b=0$, red edges cause us to flip $b$.
When $b=1$, we save visited vertices (as well as vertices reachable by back and cross edges) in $S$ and we avoid traversing red edges.

\section*{Exercise 2 (5 pts)}

Show that Dijkstra's algorithm can fail on graphs with negative costs.

\paragraph{Answer:}
On removing a node $v$ from its queue, Dijkstra's algorithm assumes that its estimate for $v$ is tight (\ie $d[v] = \mu(s, v)$) and that, if $\pi[v] \not= \bot$, then the parent pointers $\pi$ lead to $s$ and describe a path from $s$ to $v$ with this minimal cost.
If the queue contains some node $w$ such that an edge $(w, v)$ exists, then, \emph{assuming non-negative edge costs,} we know that we cannot use $w$ to construct a better path for $v$.
The invariant---that we're ``finished'' with $v$ once we remove it from the queue---breaks down with negative edge costs.
After removing $v$ from the queue, we may later find a node $w$ such that the path through $w$ lowers the cost of reaching $v$.
We weren't ``finished'' with $v$, after all.

\begin{figure}
\centering\includegraphics{ex07ex2.pdf}
\caption{Counterexample for Dijkstra with negative weights.}
\label{fig:dijkstraeg}
\end{figure}

It's easy to give a counterexample, once we fix the code.
We prefer to build the heap up-front, and to only relax edges to nodes that are not in the heap:
\begin{lstlisting}[numbers=none,xleftmargin=1cm]
dijkstra$(s)$:
	$\pi \gets \text{array}(|V|, \bot)$; $d \gets \text{array}(|V|, \infty)$; $d[s] \gets 0$
	$Q \gets \text{makeheap}(V)$	; priorities $d[v]$
	while $Q \not= \emptyset$
		let $v = \text{deleteMin}(Q)$
		for every $w$ s.t. $v \edge w$	; adj. list
			if $w \in Q$ then
				relax$(v, w)$	% adjusts priority in $Q$
\end{lstlisting}
We omit the evident code for relax.
(Note that the test $w \in Q$ can be implemented in $O(1)$ time and space using mark bits in nodes.
After makeheap, we mark every node as in $Q$.
When deleteMin returns $v$, we clear $v$'s mark.)
Now consider what happens when we run this code on the graph in \figref{fig:dijkstraeg} with source $A$.
We dequeue the nodes in order $A$, $C$, and $B$.
After initialization, $d = \{ A \mapsto 0; C, B \mapsto \infty \}$ and we dequeue $A$.
After relaxing from $A$, we have the ``shortest path forest'' (\ie $\pi$ and $d$)
\[
	\Tree [.$0A$ $0C$ $1B$ ]
\]
Thereafter, the forest never changes.
On termination, the forest says that the shortest path from $A$ to $C$ has zero cost and comprises the edge $A \edge C$.
That's wrong.
The shortest path  $A \edge B \edge C$ has cost $-9$.

\end{document}
